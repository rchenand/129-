"""Week5_129.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JWuwm_i0ZPCdRFbAwJowVX_g17Q6u_g7
"""

# Imports
import pigpio
import sys
import time
# Motor class
from Motor import Motor

# Define the motor pins.
MTR1_LEGA = 7
MTR1_LEGB = 8

MTR2_LEGA = 6
MTR2_LEGB = 5


IR_R  = 14
IR_M =  15
IR_L = 18

io = pigpio.pi()
if __name__ == "__main__":
    motor = Motor()
    case = 0
    print(io.read(IR_R))
    print(io.read(IR_L))
    print(io.read(IR_M))
    acceptingCal = True
    sees = False

    def drivebehavior(motor):
      drivingConditions = True
      sharp_turn = 0.3
      turn_const = 0.5
      power_const = 0.8
      past_mid = 0
      past_right = 0
      past_left = 0
      acceptingCal = False
      while drivingConditions:
            right_val = io.read(IR_R)
            left_val = io.read(IR_L)
            mid_val = io.read(IR_M)
            # Take appropriate action
            print(right_val)
            print(left_val)
            print(mid_val)
            # veering left
            if mid_val == 1 and right_val == 0 and left_val == 0:
                motor.set(power_const, power_const)

            # sligth left
            elif left_val == 0 and right_val ==1 and mid_val == 1:
                motor.set(power_const, power_const*turn_const)

            # very left
            elif left_val == 0 and mid_val == 0 and right_val == 1:
                motor.set(power_const, power_const*sharp_turn)

            # slight right
            elif left_val == 1 and mid_val ==1 and right_val == 0:
                motor.set(power_const*turn_const, power_const)

            # very right
            elif left_val == 1 and mid_val == 0 and right_val == 0:
                motor.set(power_const*sharp_turn, power_const)

            # off line
            elif left_val == 0 and mid_val == 0 and right_val == 0:
                # off line right
                if past_left == 1:
                   motor.set(power_const * sharp_turn, power_const)

                # off line left
                elif past_right == 1:
                   motor.set(power_const, power_const * sharp_turn)

                # off line center
                elif past_mid == 1:
                   motor.set(power_const, -1 * power_const)
                else:
                   drivingConditions = False
                   motor.set(0.7, 0.7)
                   time.sleep(0.5)

            # seeing an intersection. We check the past values and not the
            #current ones so that the bot has extra time to move forward
            elif past_left == 1 and past_right == 1 and past_mid == 1:
                drivingConditions = False
                motor.set(0.7,0.7)
                time.sleep(0.5)

           # elif past_left == 0 and past_right == 0 and past_mid =
            else:                                                                     
                drivingConditions = True

            past_left = left_val
            past_right = right_val
            past_mid = mid_val
      motor.set(0,0)

    def turn(mag):
        #90 degree turn left
        if mag == 1:
           motor.set(-0.6, 0.6)
           time.sleep(0.75)
        #270 degree turn left
        elif mag == -3:
           motor.set(0,0.7)
           time.sleep(2.5)
        #180 degree turn left
        elif mag == 2:
           motor.set(-0.7, 0.7)
           time.sleep(1)
        #180 turn right
        elif mag == -2:
           motor.set(0.7, -0.7)
           time.sleep(1)
        #90 degree turn right
        elif mag == 3:
           motor.set(0.6, -0.6)
           time.sleep(0.75)
        #270 degree turn right
        elif mag == -1:
           motor.set(0.7, 0)
           time.sleep(2.5)
        #Robot does not turn
        else:
           motor.set(0,0)
      
    def lookaround(motor):
        checks = []
        global acceptingCal
        acceptingCal = True  
        # checks front
        checks.append(checkbehavior(motor))
        global sees
        for x in range(3):
           sees = False
           acceptingCal = True
           start_time = io.get_current_tick()
           checks.append(True)
           while sees == False: # and hasn't hit 100 deg
                if (io.get_current_tick() - start_time) > 1000000:
                    print('100 deg!')
                    checks[x+1] = False
                    break #sees = True
                motor.set(-0.8, 0.8)
                time.sleep(0.1)
           print('Sees', sees)
           print(checks)

    def found(gpio, level, tick):
        global sees
        global acceptingCal
        if acceptingCal == True:
           sees = True
           print(sees)
 
    def checkbehavior(motor):
           right_val = io.read(IR_R)
           left_val = io.read(IR_L)
           mid_val = io.read(IR_M)
           if mid_val == 1 or right_val == 1 or left_val == 1:
              return True
           else:
              return False

    try:
         # checking behavior
         # L 90 deg, check, back, check, R 90 deg, check, back
          io.callback(IR_M, pigpio.RISING_EDGE, found)
          drivebehavior(motor)
          #turn(2)
          lookaround(motor)
          motor.set(0, 0)
    except ValueError as e:
        print('e')
        print('hello')
        motor.set(0,0)

# Turn off the robot
# SET MOTOR TO ZERO.
